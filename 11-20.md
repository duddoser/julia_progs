# Билеты 11-20

## Билет 11. Однопроходный алгоритм вычисления СКО.

СКО - среднеквадратичное отклонение.

Реализация:
```julia
"""Алгоритм вычисления среднего квадратического отклонения от среднего значения массива"""
function standard_deviation(A)
    Sx = 0
    Sx2 = 0
    for i in firstindex(A):lastindex(A)
        Sx += i
        Sx2 += i*i
    end
    return sqrt((Sx2 / length(A)) - ((Sx/ length(A))*(Sx/ length(A))))
end
```

## Билет 12.  Инвариант цикла. Быстрая сортировка Хоара.

Инвариантом цикла (с предусловием) называют утверждение (предикат), зависящее от фазовых переменных цикла (т.е. переменнных, которые могут изменяться в теле цикла), имеющее значение "истина" как до начала цикла, так и после любого числа его повторений.

### Быстрая сортировка Хоара

В среднем $O(n*log(n))$. 

Общая идея алгоритма состоит в следующем:

- Выбрать из массива элемент, называемый опорным. Это может быть любой из элементов массива. От выбора опорного элемента не зависит корректность алгоритма, но в отдельных случаях может сильно зависеть его эффективность.
- Сравнить все остальные элементы с опорным и переставить их в массиве так, чтобы разбить массив на три непрерывных отрезка, следующих друг за другом: «элементы меньшие опорного», «равные» и «большие».
- Для отрезков «меньших» и «больших» значений выполнить рекурсивно ту же последовательность операций, если длина отрезка больше единицы.

Инвариант цикла:

Пусть величины $K, M, L$ (индексы массива $A$) такие, что

- $\forall i \in 1:K \ \ \ A[i]<b$
- $\forall i \in K+1:L \ \ \ A[i]==b$
- $\forall i \in M+1:N \ \ \ A[i]>b$


Реализация:
```julia
function quick_sort!(A)
    if isempty(A)
        return A
    end
    N = length(A)
    K, M = part_sort!(A, rand(1:N)) # - "базовый" элемент массива выбирается случайнам образом
    quick_sort!(A[1:K])
    quick_sort!(A[M:N])
    return A
end

function part_sort!(A, b)
    N = length(A)
    K=0
    L=0
    M=N
    #ИНВАРИАНТ: A[1:K] < b && A[K+1:L] == b && A[M+1:N] > b
    while L < M 
        if A[L+1] == b
            L += 1
        elseif A[L+1] > b
            A[L+1], A[M] = A[M], A[L+1]
            M -= 1
        else # if A[L+1] < b
            L += 1; K += 1
            A[L], A[K] = A[K], A[L]
        end
    end
    return K, M+1 
    # 1:K и M+1:N - эти диапазоны индексов определяют ещё не 
    # отсортированные части массива A
end
```

## Билет 13. Инвариант цикла. Вычисление порядковых статистик и медианы массива методом Хоара

Пусть имеется числовой массив $А$. Его $k$-ой **порядковой статистикой** называется значение $k$-го элемента этого массива, которое получилось бы после реализации процедуры сортировки массива $A$.

Однако для вычисления $k$-ой порядковой статистики ($k$ считается фиксированным) вовсе не обязательно сортировать массив. Существует алгоритм вычисления этой величины, имеющий сложность всего $O(N)$, т.е. быстрый алгоритм.

В самом деле, если индекс $k$ задан, то требуемую процедуру вычисдения $k$-ой порядковой статистики легко получить из рассмотренного выше алгоритма Хоара быстрой сортировки. В самом деле, вычисление $k$-ой порядковой статистики от процедуры сортировки Хоара будет отличаться лишь тем, что для последующей после частичной сортирвки массива дальнейшая обработка массива должна бутет производиться лишь только над одной из двух полученных его частей, а именно, той из них, диапазон индексов которой включает заданное $k$.

В результате, первая частичная сортирвка даст $O(N)$ операций сравнения, вторая - $O(N/2)$, третья - $O(N/4)$ и т.д., что в сумме составит всего $O(N)$ операций.

Если длина $N$ массива нечетная, то его **медианой** называется порядковая статистика с индексом $(N-1)/2$. В случае же четной длины массива его медианой можно считать среднее арифметическое двух порядковых статистик с индексами $N/2-1$ и $N/2+1$.

Поэтому алгоритм вычисления медианы массива также может основываться на быстром алгоритме вычисления порядковых статистик.

Медиана массива, наряду со средним (средним арифметическим) значением массива является важной статистической характеристикой содержащихся в нем данных. Например, эта характеристика более адекватно оценивает уровень доходов большинства граждан, нежели простое среднее арифметическое значение уровня доходов всех граждан.

Реализация из лекций(только нахождение порядковой статистики):
```julia
function order_statistics!(A, i)
    N = length(A)
    K, M = part_sort!(A, A[rand(1:N)]) # - "базовый" элемент массива обычно выбирается случайным образом
    if K < i < M
        return A[i]
    elseif i <= K
        return order_statistics!(@view(A[1:K]), i) 
    else # i >= M
        return order_statistics!(@view(A[M:N]), i)
    end
end
order_statistics(A, i) = order_statistics!(copy(A), i)
```
Реализация Феди (есть медиана): 
```julia
"""Вычисление k-ой порядковой статистики методом Хоара"""
function order_statistics!(A::AbstractVector{T}, i::Integer)::T where T
    function find(index_range)
        left_range, right_range = part_sort!(A, index_range, A[rand(index_range)])
        if i in left_range
            return find(left_range) 
        elseif i in right_range
            return find(right_range)
        else
            return A[i]
        end
    end
    find(firstindex(A):lastindex(A))
end

@inline function part_sort!(A, index_range::AbstractUnitRange, b)
    K, L, M = index_range[1]-1, index_range[begin]-1, index_range[end]
    @inbounds while L < M 
        if A[L+1] == b
            L += 1
        elseif A[L+1] > b
            A[L+1], A[M] = A[M], A[L+1]
            M -= 1
        else
            L += 1; K += 1
            A[L], A[K] = A[K], A[L]
        end
    end    
    return index_range[begin]:K, M+1:index_range[end]
end

"""Вычисление медианы массива"""
function median(A::AbstractVector{T})
    if length(A)%2==0
        return order_statistics!(A, length(A)/2)
    else
        return (order_statistics!(A, length(A)/2)+order_statistics!(A, length(A)/2+1))/2
    end
end
```


## Билет 14. Вычисление первых k порядковых статистик O(N) (k ститать фиксированным и много меньшим N).

Реализация из лекций:
```julia
unction minimums(array, k)
    N = length(array)
    k_minimums = sort(array[1:k])
    i = k
    # ИНВАРИАНТ: issorted(k_mins) && k_mins - содержит k наименьших элементов в array[1:i]
    while i < length(array)
        i += 1
        if array[i] < k_minimums[end]
            k_minimums[end] = array[i]
            insert_end!(k_minimums)
        end
    end
    return k_minimums
end            

function insert_end!(array)::Nothing
    j = length(array)
    while j>1 && array[j-1] > array[j]
        array[j-1], array[j] = array[j], array[j-1]
        j -= 1
    end
end
```

Федина реализация:
```julia
"""Поиск первых k наименьших элементов массива"""
function minimums(array, k)
    N = length(array)
    k_minimums = sort(array[1:k])
    i = k
    while i < length(array)
        i += 1
        if array[i] < k_minimums[end]
            k_minimums[end] = array[i]
            insert_end!(k_minimums)
        end
    end
    return k_minimums
end            

function insert_end!(array)::Nothing
    j = length(array)
    while j>1 && array[j-1] > array[j]
        array[j-1], array[j] = array[j], array[j-1]
        j -= 1
    end
end
```

## Билет 15. Двунаправленная пузырьковая сортировка. (Эта сортировка также называется сортировка перемешиванием)

При сортирвке методом "пузырька" при первом проходе максимальный элемент массива перемещается в самый его конец. После второго прохода на предпоследнем месте окажется второй по величине элемент массива, и т.д. Таким образом каждый раз остается отсортировать (тем же способом) оставшуюся часть массива (без элементов массива в его конце, уже находящихся на "своих" местах).

Тут важно на каждом новом проходе уменьшать на 1 величину верхнего предела переменного индекса массива с тем, чтобы не выполнять бесполезных сравнений в уже отсортированной части массива.

Но можно таже, сделав проход по массиву слева направо, в результате которого наибольший элемент переместится в конец, сделать затем аналогичный проход справа налево, в результате которого наименьший элемент переместился бы в начало. Таким образом, чередуя проходы слева направо с проходами справа налево, можно будет уменьшать оставшуюся неотсортированной часть массива сразу с двух сторон.

Реализация:

```julia
function mixersort!(a)
    i_beg = 1
    i_end = length(a)
    while i_beg < i_end
        @inbound for i in i_beg:i_end-1 # макрос @inbounds отменяет контроль выхода за пределы массива
            if a[i] > a[i+1]
                a[i], a[i+1] = a[i+1], a[i]
            end
        end
        i_end -= 1
        @inbound for i in i_end:-1:beg+1 # i меняется в сторону уменьшения (в диапазоне шаг отрицательный)
            if a[i-1] > a[i]
                a[i-1], a[i] = a[i], a[i-1]
            end
        end
        i_beg += 1
    end
    return a
end
```
Федя:
```julia
"""Сортировка пузырьком (двухсторонняя)"""
function bubbleSortModS!(array::AbstractVector)
    counter = 0
    start = 2
    stop = length(array)-1
    step = 1
    for i in 1:(length(array)/2+1)
        for j in start:step:stop
            if step == 1
                if array[j] > array[j+step]
                    swap!(array, j, j+step)
                end
            end
            if step == -1
                if array[j] < array[j+step]
                    swap!(array, j, j+step)
                end
            end
        end
        if step == 1
            stop -= 1
        elseif step == -1
            start += 1
        end
        step = -step
        temp = start
        start = stop
        stop = temp
    end
end
```

## Билет 16. Сортировка Шелла

Сортировка пузырьком не только долгая, но и энергозатратная, потому что много раз нужно обменивать элементы. Число таких обменов можно попытаться уменьшить, если вначале сравнивать и, при нобходимости, менять местами не соседние элементы масива, а только отстоящие друг от друга на значительно большее расстояние. Затем это расстояние надо будет уменьшить и повторить ту же процедуру частичной сортировки массива с самого его начала. Постепенно меньшать расстояние между сравниваемыми элементами, и повторять процедуру частичной сортировки надо до тех пор, пока это расстояние не станет равным 1, т.е. пока, наконец, не начнут сравниваться соседние элементы массива.

В случае классической сортировки Шелла, базирующейся на сортировке вставками, в классическом её вариантк, это расстояние каждый раз уменьшается вдвое (приблизительно). При достижении расстояния между элементами равным 1 и после последнего выполнеиия сотрировки вставками уже всего массива, массив, очевидно, окажется отсортированным. Однако количество потребовавшихся при этом перестановок соседних элементов массива будет уже относительно небольшим, так все самые большие элементы ранее уже оказались перемещенными ближе к концу массива.

```julia
"""Сортировка Шелла"""
#function shellSort!(array::AbstractVector)
#    gap = length(array)
#    while gap > 0
#        for i in 1:lastindex(array)-gap
#            insertionSort!(@view array[i:gap:lastindex(array)])
#        end
#        gap = div(gap, 2)
#    end
#end

"""Сортировка Шелла более оптимизированная"""
function shellSort!(array::AbstractVector)
    gap = length(array)
    while gap > 0
        for i in 1:lastindex(array)-gap
            j = i
            while j >= firstindex(a) && array[j] > array[j+gap]
                swap!(array, j, j+gap)
                j -= gap
            end
        end
        gap = div(gap, 2)
    end
end

function swap!(array, i,j)
   array[i],array[j] = array[j],array[i]
   return array
end

"""Сортировка вставками(для первой реализации)"""
function insertionSort!(array::AbstractVector)
    for i in 2:length(array)
        for j in i-1:-1:1
            if array[i] < array[j]
                swap!(array, i, j)
            end
        end
    end
end
```

## Билет 17. Сортировка расчесыванием

Аналогично предыдущей сортировке, эта улучшеная версия уже рассмотренной сортировки - пузырьковой. Улучшения также аналогичные.

Из лекции: В случае же сортировки "расчесыванием", базирующейся на "пузырьковой" сортировке, это расстояние каждый раз уменьшается путем деления его на некоторый коэффициент, больший 1 (импирически установлено, что этот коэффициент лучше всего взять равным приблизительно 1.247). Однако в отличие от сортировки Шелла, при сортировке  "расчесыванием", когда дело уже дойдет до сравнения соседних элементов массиива, остается в точности не известно, сколько же еще раз надо пройти массив, сравнивая соседние элементы, чтобы он оказался полностью отсорированным. Но это число будет уже совсем небольшим (обычно остается сделать всего несколько проходов).

Реализация:
```julia
"""Сортировка расчетской"""
function comb_sort!(array::AbstractVector)
    gap = length(array)
    while gap != 0
        for i in firstindex(array):lastindex(array)-gap
            if array[i] > array[i+gap]
                array[i], array[i+gap] = array[i+gap], array[i]
            end
        end
        gap-=1
    end
    return array
end 
```
## Билет 18. Сортировка слияниями

Буквально цитата из лекции:

Быстрая сортировка слияниями осуществляется на основе следующей вспомогательной процедуры, осуществляющей слияние двух предварительно отсортирванных массивов в один отсортированный за $O(N1+N2)$, где $N1$, $N2$ - длины заданных отсортированных массивов. При этом это можно сделать без использования дополнителной памаяти, что очень важно.

Сортировка слиянием базируется на следующей вспомогательной процедуре.

```julia
"""
merge!(a1, a2, a3)::Nothing

    ДАНО: length(a3) == length(a1)+length(a2) && issorted(a1) && issorted(a2)
    
    РЕЗУЛЬТАТ: issorted(a3)
"""
function Base.merge!(a1, a2, a3)::Nothing
    i1, i2, i3 = 1, 1, 1
    @inbounds while i1 <= length(a1) && i2 <= length(a2) # @inbounds - передотвращает проверки выхода за пределы массивов
        if a1[i1] < a2[i2]
            a3[i3] = a1[i1]
            i1 += 1
        else
            a3[i3] = a2[i2]
            i2 += 1
        end
        i3 += 1
    end
    if i1 > length(a1)
        a3[i3:end] .= @view(a2[i2:end]) # Если бы тут было: a3[i3:end] = @view(a2[i2:end]), то это привело бы к лишним аллокациям (к созданию промежуточного массива)
    else
        a3[i3:end] .= @view(a1[i1:end])
    end
    nothing
end
```

Собственно сортирвка слияниями может быть записаны следующим образом.

```julia
function mergesort!(a)
    b = similar(a) # - вспомогательный массив того же размера и типа, что и массив a
    N = length(a)
    n = 1 # n - текущая длина блоков
    while n < N
        K = div(N,2n) # - число имеющихся пар блоков длины n
        for k in 0:K-1
            merge!(@view(a[(1:n).+k*2n]), @view(a[(n+1:2n).+k*2n]), @view(b[(1:2n).+k*2n]))
        end
        if N - K*2n > n # - осталось еще смержить блок длины n и более короткий остаток
            merge!(@view(a[(1:n).+K*2n]), @view(a[K*2n+n+1:end]), @view(b[K*2n+1:end]))
        elseif 0 < N - K*2n <= n # - оставшуюся короткую часть мержить несчем
            b[K*2n+1:end] .= a[K*2n+1:end]
        end
        a, b = b, a
        n *= 2
    end
    if isodd(log2(n)) # - если цикл был выполнен нечетное число раз
        b[:] .= a[:]  # a = copy(b) - это было бы не то же самое, т.к. тут получилась бы ссылка на новый массив, который создаст функция copy
        a = b
    end
    return a # - ссылка на исходный массив (проверить, что это так, можно с помощью ===)
end
```

## Билет 19. Инвапиант цикла. Быстрое возведение в степень

Пусть требуется вычислить целую неотрицательную степерь $a^n$ некоторого числа $n$ (на самом деле не обязательно числа, но и - матрицы, или многочлена, в общем, можно считать, что $а$ - это элемент какого-либо кольца).

Ясно, что это можно сделать за $O(n)$ операций умножения. Но возникает вопрос, а можно ли это сделать быстрее. Оказывается, что это всегда можно сделать за $log(n)$ операций, т.е. "быстро".

В частном случае, когда число n - есть некоторая степень 2 это не вызывает вопроса. Например, вычислить $a^8$ можно всего за 3 операции умножения ($3=log_28$):

```julia
a2 = a*a
a4 = a2*a2
a8 = a4*a4
```

Или, когда $n$ есть произвольная степень двойки (целая не отрицательная), быстрый алгоритм возведения в эту степень мог бы выглядеть так:

```julia
# число n - есть некоторая целая неотрицательная степень 2
p, k = a, n
#ИНВАРИАНТ: p^k = a^n
while k != 1
    p *= p
    k ÷= 2 # k гарантированно делится на 2, т.к. по предположению n - степень 2
end
```

В случае, когда целое неотрицательное число $n$ не является степенью 2 напрямую приведенный алгоритм применить нельзя. Тут трудность будет состоять в том, что не всегда переменная $k$ будет делиться на 2.

Идея быстрого алгоритма в общем случае состоит в том, что если на некотором шаге рассмотренного выше алгоритма число k окажется нечетным, то вместо деления из него надо будет вычесть 1, а затем уже, на следующей итерации, оно гарантировано поделится на 2.

Эту идею можно реализовать следующим образом.

```julia
k, t, p = n, 1, a

#ИНВАРИАНТ: p^k*t=a^n 
while k>0
    if even(k) # k - четное
        k ÷= 2
        p *= p # т.к. p^k = (p*p)^k*(t/2)
    else
        k -= 1
        t *= p # т.к. p^k * t = p^(k-1)*(p*t)
    end   
end
#УТВ: t = a^n
```

Остается только понять, что сложность этого алгоритма попрежнему будет иметь оценку $O(\log(n))$. В самом деле,
в наихудшем случае 1 придется вычитать через раз. В этом случае для числа повторений цикла очевидна оценка сверху $2\log_2(n)$, а это и есть $O(\log(n))$

## Билет 20. Инвариант цикла. Приближенное вычисление логарифма (не используя разоржения в ряд)

Пусть требуется составить алгоритм вычисления логарифма $log_a(x)$ по некоторому основанию $a$. Для произвольного значения аргумента $x$ расчитывать на получения точного ответа, имея ввиду вычисления с плавающей точкой, не приходится. Поэтому задачу сформулируем так: для произвольно заданного значения аргумента $x$ и для заданной, сколь угодно малой величины абсолютной погрешности $\varepsilon>0$ найти значение $y: |\log_a(x)-y| <= \varepsilon$.

Для определенности будем считать $a>1$. Обозначим $\hat{y}=\log_a(x), \ \ \ \Delta = \hat{y}-y$, тогда

$$
x = a^{\hat{y}} = a^{y+\Delta}=a^ya^{\Delta}=a^{y}z^t
$$

где $z,t$ - новые переменные, выбором значений которых мы можем свободно распорядиться, лишь бы $a^{\Delta}=z^t$. А именно, имеем

$$
\Delta=t\log_az
$$

Откуда, исходя из требования $|\Delta| <= \varepsilon$, получаем

$$
|\Delta|=|t||\log_az|<=\varepsilon
$$

Для выполнения последнего неравенства достаточно, что бы $|t|<=\varepsilon$ и $|\log_az|<=1$. Откуда, учитывая, что $a>1$, находим явное условие для второй переменной $1/a <= z <= a$.

Т.е. если добиться того, что бы

$$
|t|<=\varepsilon, \ \ \ 1/a <= z <= a
$$

то задача будет решена, т.е. получится, что $∣\log_a(x)−y∣<=ε$

Соответствующий алгоритм выглядит следующим образом.

```julia
z, t, y = x, 1, 0
#ИНВАРИАНТ: a^y * z^t == x (=const)
while z > a || z < 1/a || t > ε   
    if z > a
        z /= a
        y += t # т.к. z^t = (z/a)^t * a^t
    elseif z < 1/a
        z *= a
        y -= t # т.к. z^t = (z*a)^t * a^-t
    else # t > ε
        t /= 2
        z *= z # т.к. z^t = (z*z)^(t/2)
    end
end
#УТВ: y: |log_a(x)-y| <= ε
```
