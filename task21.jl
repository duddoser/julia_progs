# f(x)=0
# где f: [a;b] -> R  - некоторая непрерывная на отрезке [a;b] функция, и при этом выполнены следующие два условия:
# 1. на открытом интервале (a;b) уравнение имеет ровно один корень (этот интервал называют интервалом локализации корня);
# 2. на концах [a;b] значения функции имеют противоположные знаки, т.е. f(a) * f(b)<0.
# 3. Пусть задана максимально допустимая абсолютная погрешность e, с которой требуется вычислить значение корня.
# Тогда задача сводится к тому, чтобы найти такой отрезок [a'; b'], чтобы, во-первых, он содержал корень,
# и, во-вторых, его длина не превосходила бы величины e. 
# Тогда любую точку этого отрезка, например, его середину, можно принять за искомое приближенное решение уравнения.

function approx_value(f::Function, a, b, e)
    y_a=f(a)
    # ИНВАРИАНТ: f(a)*f(b) < 0 (т.е. (a,b) - содержит корень)
    while b-a > e
        x_middle = (a+b)/2
        y_middle = f(x_middle)
        if y_middle == 0
            return x_midle
        end
        if y_middle * y_a > 0 
            a = x_middle
        else
            b = x_middle
        end
    end
    return (a + b)/2
end

# Пример для нелинейноц функции y - x^2 - 4
# Например запускаем approx_value(sq, 2, 4, 0.001)
function sq(a)
    return a^2 - 4
end
