# Для того, чтобы из заданной перестановки получить "следующую", требуется:

# 1. перемещаясь из конца перестановки p к её началу, найти ближайшую позицию k,
# для которой k+1-ый элемент больше k-го. Причем, если такой позиции не окажется
# (в этом случае будем считать k=0), то это означает, что данная перестановка является "последней".
# Т.е., если перестановка p не является "последней", имеем p[k]<p[k+1] > p[k+2]>...>p[n]
# 
# 2. затем, в "хвосте" p[k+1:n] надо найти позицию i, на которой стоит наименьшее значение, большее p[k];
# 
# 3. затем, элементы p[k] и p[i] требуется поменять местами,
# а все элементы p[i+1]...p[n] переставить в обратном порядке.


# На примере перестановки [1, 3, 2], следующая [2, 1, 3]:
# 1. [1, 3, 2]: k = 1, p[k] < p[k+1] > p[k+2]
# 2. i = 3. Меняем p[k] и p[i] местами: [2, 3, 1]
# 3. p[i+1]...p[n] переставляем в обратном порядке: [2, 1, 3]

function next_permute!(p::Vector{T}) where T<:Integer
    n = length(p)
    k = 0 # или firstindex(p)-1
    for i in reverse(1:n-1) # или reverse(firstindex(p):lastindex(p)-1)
        if p[i] < p[i+1]
            k = i
            break
        end
    end
    k == 0 && return nothing # т.е. p[begin]>p[begin+1]>...>p[end] - случай выхода, когда перестановка последняя
 
    #УТВ: p[k]<p[k+1] > p[k+2]>...>p[end]
    i = k + 1
    while i < n && p[i+1] > p[k] # i < lastindex(p) && p[i+1] > p[k]
        i += 1
    end
    #УТВ: p[i] - наименьшее из всех p[k+1:end], большее p[k]
    p[k], p[i] = p[i], p[k]
    #УТВ: по-прежнему p[k+1]>...>p[end]
    reverse!(@view p[k+1:end])
    return p
end

#Тестирование. Тест точно такой же, как в размещениях
p = [1, 2, 3]
while !isnothing(p)
    println(p)
    global p = next_permute!(p)
end